Index: SECEdgar/filings/base.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import datetime\nimport errno\nimport os\nimport requests\nfrom SECEdgar.base import _EDGARBase\nfrom SECEdgar.utils import _sanitize_date\nfrom SECEdgar.utils.exceptions import FilingTypeError, CIKError\nfrom SECEdgar.filings.filing_types import FilingType\nfrom SECEdgar.filings.cik import CIK\n\n\nclass Filing(_EDGARBase):\n    \"\"\"Base class for receiving EDGAR filings.\n\n    Attributes:\n        cik (str): Central Index Key (CIK) for company of interest.\n        filing_type (SECEdgar.filings.filing_types.FilingType): Valid filing type enum.\n        dateb (Union[str, datetime.datetime], optional): Date after which not to fetch reports.\n            Defaults to today.\n\n    .. versionadded:: 0.1.5\n    \"\"\"\n\n    def __init__(self, cik, filing_type, dateb=datetime.datetime.today(), **kwargs):\n        super(Filing, self).__init__(**kwargs)\n        self._dateb = _sanitize_date(dateb)\n        if not isinstance(filing_type, FilingType):\n            raise FilingTypeError(FilingType)\n        self._filing_type = filing_type\n        self._cik = self._validate_cik(cik)\n        self._params['action'] = 'getcompany'\n        self._params['owner'] = 'exclude'\n        self._params['output'] = 'xml'\n        self._params['start'] = 0\n        self._params['type'] = self.filing_type.value\n        self._params['dateb'] = self._dateb\n\n    @property\n    def url(self):\n        return \"browse-edgar\"\n\n    @property\n    def dateb(self):\n        return _sanitize_date(self._dateb)\n\n    @dateb.setter\n    def dateb(self, val):\n        self._dateb = _sanitize_date(val)\n\n    @property\n    def filing_type(self):\n        return self._filing_type\n\n    @filing_type.setter\n    def filing_type(self, filing_type):\n        if not isinstance(filing_type, FilingType):\n            raise FilingTypeError(FilingType)\n        self._filing_type = filing_type\n\n    @property\n    def cik(self):\n        return Filing._validate_cik(self._cik)\n\n    @staticmethod\n    def _validate_cik(cik):\n        \"\"\"Validates that given CIK *could* be valid.\n\n        Args:\n            cik (Union[CIK, str, int]): Central index key (CIK) to validate.\n\n        Returns:\n            cik (Union[str, list of str]): Validated CIK.\n                Note that the CIK is only validated in\n                that it *could* be valid. CIKs formatted as\n                10 digits, but not all 10 digit\n                numbers are valid CIKs.\n\n        Raises:\n            ValueError: If given cik is not str, int, or CIK object.\n            CIKError: If cik is not a 10 digit number or valid CIK object\n        \"\"\"\n        # creating CIK object should check to see if ciks are valid\n        if not isinstance(cik, CIK):\n            if not isinstance(cik, (str, int)):\n                raise ValueError(\"CIK must be of type str or int.\")\n            elif isinstance(cik, str):\n                if len(cik) != 10 or not cik.isdigit():\n                    raise CIKError(cik)\n            elif isinstance(cik, int):\n                if cik > 10**10:\n                    raise CIKError(cik)\n                elif cik < 10**9:\n                    return str(cik).zfill(10)  # pad with zeros if less than 10 digits given\n            return str(cik)\n        else:\n            return cik.cik\n\n    def get_urls(self):\n        \"\"\"Get urls for all CIKs given to Filing object.\n\n        Returns:\n            urls (list): List of urls for txt files to download.\n        \"\"\"\n        if isinstance(self._cik, (list, tuple, set)):\n            urls = [self._get_cik_urls(cik) for cik in self._cik]\n            return urls\n        else:\n            return self._get_cik_urls(self._cik)\n\n    def _get_cik_urls(self, cik):\n        \"\"\"\n        Get all urls for specific company according to CIK that match\n        dateb, filing_type, and count parameters.\n\n        Args:\n            cik (str): CIK for company.\n\n        Returns:\n            txt_urls (list of str): Up to the desired number of URLs for that specific company\n            if available.\n        \"\"\"\n        self.params['CIK'] = cik\n        data = self.get_soup()\n        links = []\n\n        # paginate\n        while len(links) < self._client.count:\n            links.extend([link.string for link in data.find_all(\"filinghref\")])\n            self.params[\"start\"] += 100\n            if len(data.find_all(\"filinghref\")) == 0:\n                break\n        self.params[\"start\"] = 0  # set start back to 0 after paginating\n        txt_urls = [link[:link.rfind(\"-\")] + \".txt\" for link in links]\n        return txt_urls[:self._client.count]\n\n    def _make_dir(self, directory):\n        \"\"\"Make directory based on filing info.\n\n        Args:\n            directory (str): Base directory where filings should be saved from.\n\n        Raises:\n            OSError: If there is a problem making the directory.\n\n        Returns:\n            None\n        \"\"\"\n        path = os.path.join(directory, self.cik, self.filing_type.value)\n\n        if not os.path.exists(path):\n            try:\n                os.makedirs(path)\n            except OSError as e:\n                if e.errno != errno.EEXIST:\n                    raise OSError\n\n    @staticmethod\n    def _sanitize_path(directory):\n        return os.path.expanduser(directory)\n\n    @staticmethod\n    def get_filing(url):\n        \"\"\"\n        Returns all text data from given filing url.\n\n        Args:\n            url (str): URL for specific filing.\n\n        Returns:\n            response.text (str): All text from filing.\n        \"\"\"\n        return requests.get(url).text\n\n    def save(self, directory):\n        \"\"\"Save files in specified directory.\n\n        Args:\n            directory (str): Path to directory where files should be saved.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If no text urls are available for given filing object.\n        \"\"\"\n        directory = self._sanitize_path(directory)\n        self._make_dir(directory)\n        urls = self.get_urls()\n        if len(urls) == 0:\n            raise ValueError(\"No urls available.\")\n        doc_names = [url.split(\"/\")[-1] for url in urls]\n        for (url, doc_name) in list(zip(urls, doc_names)):\n            data = self.get_filing(url)\n            path = os.path.join(directory, self.cik, self.filing_type.value, doc_name)\n            with open(path, \"ab\") as f:\n                f.write(data.encode(\"ascii\", \"ignore\"))\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- SECEdgar/filings/base.py	(revision 6ea3f74fe75c80c04b903b5b8b2e3058bbfadefc)
+++ SECEdgar/filings/base.py	(date 1576645236813)
@@ -27,6 +27,8 @@
         if not isinstance(filing_type, FilingType):
             raise FilingTypeError(FilingType)
         self._filing_type = filing_type
+        if not isinstance(cik, CIK):
+            raise CIKError(cik)
         self._cik = self._validate_cik(cik)
         self._params['action'] = 'getcompany'
         self._params['owner'] = 'exclude'
@@ -59,41 +61,7 @@
 
     @property
     def cik(self):
-        return Filing._validate_cik(self._cik)
-
-    @staticmethod
-    def _validate_cik(cik):
-        """Validates that given CIK *could* be valid.
-
-        Args:
-            cik (Union[CIK, str, int]): Central index key (CIK) to validate.
-
-        Returns:
-            cik (Union[str, list of str]): Validated CIK.
-                Note that the CIK is only validated in
-                that it *could* be valid. CIKs formatted as
-                10 digits, but not all 10 digit
-                numbers are valid CIKs.
-
-        Raises:
-            ValueError: If given cik is not str, int, or CIK object.
-            CIKError: If cik is not a 10 digit number or valid CIK object
-        """
-        # creating CIK object should check to see if ciks are valid
-        if not isinstance(cik, CIK):
-            if not isinstance(cik, (str, int)):
-                raise ValueError("CIK must be of type str or int.")
-            elif isinstance(cik, str):
-                if len(cik) != 10 or not cik.isdigit():
-                    raise CIKError(cik)
-            elif isinstance(cik, int):
-                if cik > 10**10:
-                    raise CIKError(cik)
-                elif cik < 10**9:
-                    return str(cik).zfill(10)  # pad with zeros if less than 10 digits given
-            return str(cik)
-        else:
-            return cik.cik
+        return self._cik
 
     def get_urls(self):
         """Get urls for all CIKs given to Filing object.
Index: SECEdgar/filings/cik_validator.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- SECEdgar/filings/cik_validator.py	(date 1576645286784)
+++ SECEdgar/filings/cik_validator.py	(date 1576645286784)
@@ -0,0 +1,7 @@
+class CIKValidator(object):
+    def __init__(self, ciks):
+        self._ciks = ciks
+
+    def validate(self):
+        # check that CIK is valid
+        pass
